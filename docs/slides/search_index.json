[["day-3-intoduction-to-r.html", "1 Day 3 - intoduction to R 1.1 Rstudio, and basics 1.2 Data exploration pipelines 1.3 Getting started in R 1.4 Working with Vectors 1.5 Working with Dataframes", " 1 Day 3 - intoduction to R Rstudio etc 1.1 Rstudio, and basics Rstudio 1 ## [1] 1 x &lt;- 1 x = 1 x &lt;- 1 “Scoping” 1 is a term that you can really get into, but for now, just use &lt;- 2 1.2 Data exploration pipelines Approach: an Rmd tutorial with a simple dataset in R. This is meant to be a motivation for what one can do in R, not necessarily understanding syntax of every function/operation used Topics/Exercises Present a conceptual framework for a pipeline - more of a tutorial Use an Rmd file for this and introduce how to navigate the Rmd file Scholars can execute a given Rmd Scholars can modify a given Rmd Scholars know what the major pieces of an Rmd are (code and not code) Scholars know about caching and arguments for code chunks Scholars know how to make their own new Rmd file and run it Load a simple dataset in R - the iris dataset, peek at the table with head, summarize the columns, and make a scatter plot with base R. This introduces several topics Requires: interacting with R, calling functions, and saving variables 1.3 Getting started in R Learning Goals: Apply internet searches, help functions, and documentation to learn to use the appropriate functions. Assign and manipulate variables within the current environment/session in R. Create, modify, and access into a vector (an ordered grouping of elements). Create, modify, and access into a dataframe (an ordered two-dimensional grouping of elements with rows and columns). 1.3.1 Getting Help in R If you run into any error while using R, it is a great idea to look up your error message in Google and read through forum posts on StackOverflow. You may find it also helps to know more about your session info such as the version of R you are using, and what packages you have currently loaded. sessionInfo() You can look up what functions do using either a question mark ? or the help function. ?rm help(rm) 1.3.2 Variables and Data Types You can assign variables using the = or &lt;- operators. I will use the &lt;- operator exclusively going forward. save.num &lt;- 7 save.num ## [1] 7 Variables are mutable: you can overwrite the saved value of a variable with another value. save.num = 10 save.num ## [1] 10 Variables can be saved as other values such as character strings or boolean values (True or False). save.string &lt;- &quot;hello&quot; save.bool &lt;- TRUE You can check what variables you have assigned in your current working environment. ls() ## [1] &quot;save.bool&quot; &quot;save.num&quot; &quot;save.string&quot; You can also remove saved variables. rm(save.num) ls() ## [1] &quot;save.bool&quot; &quot;save.string&quot; 1.4 Working with Vectors You can create vectors (an ordered list of elements) by combining elements with the c function. first.vector &lt;- c(38, 32, 45, 23, 6, 56, 234, 1239, 123, 123, 342, 1234) second.vector &lt;- c(1, 34, 10) first.vector ## [1] 38 32 45 23 6 56 234 1239 123 123 342 1234 second.vector ## [1] 1 34 10 third.vector &lt;- c(first.vector, second.vector) third.vector ## [1] 38 32 45 23 6 56 234 1239 123 123 342 1234 1 34 10 fruits &lt;- c(&quot;apples&quot;, &quot;oranges&quot;, &quot;bananas&quot;) R comes with pre-built variables that you can use, such as the vector of all alphabetic characters. letters ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; ## [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; LETTERS ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; ## [20] &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; There are several helpful functions and an operator that can speed up your ability to generate vectors of numeric values. Explore what the : operator does below and generate a few numeric vectors of your own. 1:4 ## [1] 1 2 3 4 ?seq ?rep z &lt;- seq(-pi, pi, length = 20) z ## [1] -3.1415927 -2.8108987 -2.4802047 -2.1495108 -1.8188168 -1.4881228 ## [7] -1.1574289 -0.8267349 -0.4960409 -0.1653470 0.1653470 0.4960409 ## [13] 0.8267349 1.1574289 1.4881228 1.8188168 2.1495108 2.4802047 ## [19] 2.8108987 3.1415927 x &lt;- c(1, 3, 2) x ## [1] 1 3 2 y &lt;- c(1, 4, 3) length(x) ## [1] 3 length(y) ## [1] 3 What does the length function do? Test it on a few more vectors that you have created. x + y ## [1] 2 7 5 You can perform mathematical operations on an entire numeric vector all at once. first.vector * 2 ## [1] 76 64 90 46 12 112 468 2478 246 246 684 2468 ?sin sin(first.vector) ## [1] 0.2963686 0.5514267 0.8509035 -0.8462204 -0.2794155 -0.5215510 ## [7] 0.9988167 0.9364937 -0.4599035 -0.4599035 0.4201397 0.6019277 1.4.1 Indexing and Subsetting Indexing is a way to access into a vector (or matrix/data frame) and pull out certain elements. There are multiple ways to index into a vector, one of the easiest ways is to pull out an element based on its order/position in the grouping (its index). We use [] immediately after the name of the grouping (in this case a vector) to access into it. second.vector[2] # pull out second element ## [1] 34 fruits[3] # pull out third fruit ## [1] &quot;bananas&quot; fruits[2:3] # pull out 2nd and 3rd fruit ## [1] &quot;oranges&quot; &quot;bananas&quot; fruits[c(1, 3)] # pull out 1st and 3rd fruit ## [1] &quot;apples&quot; &quot;bananas&quot; You can remove elements of a vector by using the same syntax of indexing, but instead put a negative sign in front of the index number. fruits[-1] ## [1] &quot;oranges&quot; &quot;bananas&quot; 1.4.2 Using Logicals You can also access elements in a vector that meet certain criteria (using conditional logic). second.vector &lt; 20 ## [1] TRUE FALSE TRUE second.vector[second.vector &lt; 20] ## [1] 1 10 You can use the standard comparison operators like &gt; or &lt; to check greater than or less than. You can also use == to check for equality or != to check that values are not equal. save.num &lt;- 7 save.num + 10 ## [1] 17 save.num != 8 ## [1] TRUE save.num == 8 ## [1] FALSE Conditional logic is where a statement evaluates to True or False. You can pair these conditional statements with an if/else statement that breaks up the code and only executes parts of the code where conditions are met. test.num &lt;- 30 if (test.num &lt; 10) { print(&quot;small&quot;) } else { print(&quot;big&quot;) } ## [1] &quot;big&quot; 1.5 Working with Dataframes The most common data format we will deal with is a dataframe format. This means that data is stored in a 2D array with the rows referring to individual measurements (single patients, samples, cells, etc.) and the columns referring to parameters (genes, proteins, etc.) measured in each individual. my.data &lt;- matrix(data = c(1, 2, 3, 4, 5, 6, 7, 8, 9), nrow = 3, ncol = 3) my.data ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 We now convert this matrix into a dataframe type. my.data &lt;- as.data.frame(my.data) You can index into a dataframe and pull out one or more cells within the dataframe. my.data[1, 3] ## [1] 7 Yo can pull out multiple elements at a time, specifying which row and column they reside in. my.data[c(1, 2), c(2, 3)] ## V2 V3 ## 1 4 7 ## 2 5 8 my.data[1:2, 2:3] ## V2 V3 ## 1 4 7 ## 2 5 8 If you provide the row and not the column, or vice versa, by default R will pull out all of the available columns and rows respectively. my.data[1:2, ] # pulls out the first two rows and all columns ## V1 V2 V3 ## 1 1 4 7 ## 2 2 5 8 my.data[, 1:2] # pulls out the first two columns and all rows ## V1 V2 ## 1 1 4 ## 2 2 5 ## 3 3 6 It’s possible to also remove elements in a dataframe using the negative sign. my.data[-c(1, 3), ] # removes the first and third rows ## V1 V2 V3 ## 2 2 5 8 There are a few different functions you can use to investigate a dataframe, the size of it, and other aspects. dim(my.data) ## [1] 3 3 We work with a dataframe instead of just a matrix because dataframes can tolerate different datatypes in the same table. The gapminder dataset is a pre-made dataset that we can play around with. library(gapminder) head(gapminder) ## # A tibble: 6 x 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 1952 28.8 8425333 779. ## 2 Afghanistan Asia 1957 30.3 9240934 821. ## 3 Afghanistan Asia 1962 32.0 10267083 853. ## 4 Afghanistan Asia 1967 34.0 11537966 836. ## 5 Afghanistan Asia 1972 36.1 13079460 740. ## 6 Afghanistan Asia 1977 38.4 14880372 786. We can also generate our own dataframes from vectors that we put together into a table. cats &lt;- data.frame(coat = c(&quot;calico&quot;, &quot;black&quot;, &quot;tabby&quot;), weight = c(2.1, 5.0, 3.2), likes_string = c(1, 0, 1)) cats ## coat weight likes_string ## 1 calico 2.1 1 ## 2 black 5.0 0 ## 3 tabby 3.2 1 You can check what kind of data you are working with using the class and/or typeof functions. class(my.data) # tells you that A is a dataframe ## [1] &quot;data.frame&quot; You can use the following functions to investigate aspects of a given dataset. dim(gapminder) ## [1] 1704 6 colnames(gapminder) ## [1] &quot;country&quot; &quot;continent&quot; &quot;year&quot; &quot;lifeExp&quot; &quot;pop&quot; &quot;gdpPercap&quot; summary(gapminder) ## country continent year lifeExp ## Afghanistan: 12 Africa :624 Min. :1952 Min. :23.60 ## Albania : 12 Americas:300 1st Qu.:1966 1st Qu.:48.20 ## Algeria : 12 Asia :396 Median :1980 Median :60.71 ## Angola : 12 Europe :360 Mean :1980 Mean :59.47 ## Argentina : 12 Oceania : 24 3rd Qu.:1993 3rd Qu.:70.85 ## Australia : 12 Max. :2007 Max. :82.60 ## (Other) :1632 ## pop gdpPercap ## Min. :6.001e+04 Min. : 241.2 ## 1st Qu.:2.794e+06 1st Qu.: 1202.1 ## Median :7.024e+06 Median : 3531.8 ## Mean :2.960e+07 Mean : 7215.3 ## 3rd Qu.:1.959e+07 3rd Qu.: 9325.5 ## Max. :1.319e+09 Max. :113523.1 ## We can try to look at the beginning of a specific column in this dataset. Dataframes that have names for their columns allow you to index into the columns specifically by name using the $ operator as shown below. head(gapminder$continent) ## [1] Asia Asia Asia Asia Asia Asia ## Levels: Africa Americas Asia Europe Oceania You can add new rows and columns using the rbind and cbind functions. cats &lt;- cbind(cats, length = c(2, 3, 1)) cats ## coat weight likes_string length ## 1 calico 2.1 1 2 ## 2 black 5.0 0 3 ## 3 tabby 3.2 1 1 You can also remove rows and columns using the trick with a negative index. cats[, -1] ## weight likes_string length ## 1 2.1 1 2 ## 2 5.0 0 3 ## 3 3.2 1 1 cats[-1, ] ## coat weight likes_string length ## 2 black 5.0 0 3 ## 3 tabby 3.2 1 1 You can merge two dataframes together using the rbind function assuming that their columns match up correctly. newcats &lt;- data.frame(coat = c(&quot;white&quot;, &quot;gold&quot;, &quot;silver&quot;), weight = c(3.1, 5.3, 1.9), likes_string = c(1, 0, 0), length = c(4, 2, 3)) newcats ## coat weight likes_string length ## 1 white 3.1 1 4 ## 2 gold 5.3 0 2 ## 3 silver 1.9 0 3 cats &lt;- rbind(cats, newcats) cats ## coat weight likes_string length ## 1 calico 2.1 1 2 ## 2 black 5.0 0 3 ## 3 tabby 3.2 1 1 ## 4 white 3.1 1 4 ## 5 gold 5.3 0 2 ## 6 silver 1.9 0 3 1.5.1 Type Coercion and Factors ?? cats$coat &lt;- as.factor(cats$coat) ??? cats &lt;- rbind(cats, c(coat = &quot;spotted&quot;, weight = 2.4, likes_string = 0, length = 2.5)) ## Warning in `[&lt;-.factor`(`*tmp*`, ri, value = &quot;spotted&quot;): invalid factor level, ## NA generated cats ## coat weight likes_string length ## 1 calico 2.1 1 2 ## 2 black 5 0 3 ## 3 tabby 3.2 1 1 ## 4 white 3.1 1 4 ## 5 gold 5.3 0 2 ## 6 silver 1.9 0 3 ## 7 &lt;NA&gt; 2.4 0 2.5 cats$coat ## [1] calico black tabby white gold silver &lt;NA&gt; ## Levels: black calico tabby gold silver white What has happened with this new addition? If you tried to add a new cat to the dataframe that had a color that wasn’t already represented in the data, chances are you had a warning and that color was turned to NA. cats$coat ## [1] calico black tabby white gold silver &lt;NA&gt; ## Levels: black calico tabby gold silver white You may have seen certain parts of dataframes are factors with levels. Factors are a special data type that deals with categorical data. They can be handy for certain manipulations or visualizations, but once a factor is created, it doesn’t let you easily add new categories that were not in the original set. The easiest way around this is to treat the column as characters instead of as factors. cats &lt;- rbind(cats, c(coat = &quot;calico&quot;, weight = 3.2, likes_string = 1, length = 3)) cats$coat ## [1] calico black tabby white gold silver &lt;NA&gt; calico ## Levels: black calico tabby gold silver white cats$coat &lt;- as.character(cats$coat) cats &lt;- rbind(cats, c(coat = &quot;brown&quot;, weight = 4.6, likes_string = 0, length = 2.5)) cats$coat ## [1] &quot;calico&quot; &quot;black&quot; &quot;tabby&quot; &quot;white&quot; &quot;gold&quot; &quot;silver&quot; NA &quot;calico&quot; ## [9] &quot;brown&quot; Scoping is a computer science term for where a variable is define, globally, locally, and how locally. Here’s a site with more info ↩ You can also go the other way, like 1 -&gt; x, but nobody does that↩ "]]
