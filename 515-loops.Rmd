### Loops - doing a similar task multiple times

You will want to repeat this analysis for multiple file.
This automation is great, really useful for scaling your analyses. 

Let's do this for all the proteins.
The simplest way of doing this is to copy and paste it, and change the filename.

```{r,copy_paste_rep,cache=T}
viral_protein_data <- read.delim("data/viral_structural_proteins/viral_proteins_002.tsv",
      sep="\t",header=F, as.is=T)
nchar(viral_protein_data$V3[[1]])
viral_protein_data <- read.delim("data/viral_structural_proteins/viral_proteins_003.tsv",
      sep="\t",header=F, as.is=T)
nchar(viral_protein_data[1,"V3"])
```

Go ahead and do this for all 242 proteins 

---

... just kidding.

This is a lot of work, and each time we do this we can introduce errors.
If we ever have more files, we have to copy and paste more. If we ever want
to change an argument for all of them, we have to do each one.

Instead, we can work with a list of all the files available:

```{r,list_files,cache=T}
list.files(path="data/viral_structural_proteins")[1:5]
```

Note that I put a `[1:5]` to limit it to the first 5.
You could also use `head()`. It's a good idea to work
with a small subset of files while you are iterating
through development, then scale it up to the entirety.

Now how do you calculate the number of characters for each protein?

How do we do this for every file listed ... ?

---

#### What are loops?

<!-- video -->

Loops are for running a "code block" as many times
as the "condition" determines.

- A "code block" is either one line of code, or multiple
    lines of code surrounded by curly brackets - {}

        {
            code <- "in a block" 
            with <- "multiple lines" 
        }

    The code just runs. Yep. It's that simple.

- A "condition" is an expression of code that
    can either evaluate to either `TRUE` or `FALSE`, or 
    set a variable for each time running the code block.
    This is often just before the code block, in `()` parentheses.

The most common form of these kind of "control statements" is a `for` loop.
Other "control statements" or "flow control statements" are
`while`, `repeat`, and `if`.

Let's look up what they do, with `` ?`for` ``
Note the back ticks! These are a trick in R to make anything
be interpreted as literally what you type, and not
any special characters. Like `` ?`+` ``, or `` ?`?` ``

---

Here's an example loop:

```{r,loop_example_1,cache=T}
for (i in 1:4) {
  print(i)
}
```

The pieces:

- `(i in 1:4)` is what is being looped over - `1:4` is a vector of 
  1 through 4 that is created, and it is put one at a time into `i` 
  (a new variable). You need the parentheses.
  
- `{` and `}` denote the opening and closing brackets, specify the
  "code block" that is run each time.
  
- inside this "code block" is `print(i)` - it prints the variable `i`,
  which is set to a value of 1, 2, 3, or 4 for each loop

---

How do we loop through and print each file name?

What are the (1) code block and (2) loop condition ?

```{=html}
<div class="incremental">
```


```{r,loop_through_files,cache=T}
for (i in list.files(path="data/viral_structural_proteins")[1:5] ) {
  print(i)
}
```

How do we modify this to calculate the protein length?
I add a line where we use `nchar`, but `i` is the filename instead of me
typing it in there.

```{r,loop_and_calculate_errors,cache=T,error=T}
for (i in list.files(path="data/viral_structural_proteins")[1:5] ) {
  print(i)
  print(nchar(read.delim(i)$V3[[1]]))
}
```

```{=html}
</div>
```

Error! It is looking for a file `viral_proteins_000.tsv`, but it is looking
in _this directory_. It is actually in `data/viral_structural_proteins`.
Look up the `list.files` documentation, and find how to get it to return
the full name of the file.
 
---

Next, this should work...

```{r,loop_and_calculate,cache=T}
for (i in list.files(path="data/viral_structural_proteins",
                     full.names=T)[1:5] ) {
  print(nchar(read.delim(i,sep="\t",header=F,as.is=T)$V3[[1]]))
}
```

And yep, we have lengths of protein sequences.

...

What now?

---

#### Storing values from a loop

How do we store these values for later analysis?

In other languages, "append". But R is not built that way. It'll work,
but it's very inefficient. The "R-way" to store values from a loop
is to define a vector of the right length, 
then put each element in it.

Here's some example vectors that we can create.

```{r,vector_of_size,cache=T}
vector("character",10)
vector(mode="numeric",length=5)
vector("logical",2)
```

---

Okay, but how do we access each position to save the value?
We need to turn out list of files into indicies.
We'll save it first so we can count how many there are.

`seq_along` is handy function to create a number sequence along a vector, 
otherwise use something like `seq(1,length(x))`.

```{r,loop_save_and_index,cache=T}
first_five <- list.files(path="data/viral_structural_proteins")[1:5]

for (i in seq_along(first_five) ) {
    print(i)
    print(first_five[i])
}
```

---

Putting these together, we can create and save a vector of file names:

```{r,loop_save_and_index_filenames,cache=T}
first_five <- list.files(path="data/viral_structural_proteins")[1:5]
filenamez <- vector("character",length(first_five))

for (i in seq_along(first_five) ) {
  filenamez[i] <- first_five[i]
}

filenamez
```

---

However... there's some other files in there, isn't there?
A `viral_structural_proteins.fasta`?

Let's ignore that from the `list.files` call by using the argument
`pattern=".*.tsv"` argument.
And we'll get back to the FASTA later...

---

And finally calculate the length of each protein:

```{r,loop_to_calc_lengths_work,cache=T,error=T}
first_five <- list.files(path="data/viral_structural_proteins",
                         full.names=T, pattern=".*tsv")[1:5]
lengthz <- vector("character",length(first_five))

for (i in seq_along(first_five) ) {
  lengthz[i] <- nchar( read.delim(first_five[i],
      header=F,as.is=T,sep="\t")$V3[[1]]
    )
}

lengthz
```

---

Now we can take off the `[1:5]` limiter, and do the whole set:

```{r,loop_to_calc_lengths_all,cache=T,error=T}
first_five <- list.files(path="data/viral_structural_proteins",
                         full.names=T, pattern=".*tsv")
lengthz <- vector("character",length(first_five))

for (i in seq_along(first_five) ) {
  lengthz[i] <- nchar( read.delim(first_five[i],
      header=F,as.is=T,sep="\t")$V3[[1]]
    )
}
```

---

How do we go about visualizing/analyzing this?

```{r,base_viz_protein_lengths_error,cache=T,error=T}
hist(lengthz)
```

er what...? Debug! What is `lengthz`?

```{r,debug_lengthz,cache=T}
str(lengthz)
```

Character? Let's try numeric instead...

---

```{r,loop_to_calc_lengths_all_fixed,cache=T,error=T}
first_five <- list.files(path="data/viral_structural_proteins",
                         full.names=T, pattern=".*tsv")
lengthz <- vector("numeric",length(first_five))

for (i in seq_along(first_five) ) {
  lengthz[i] <- nchar( read.delim(first_five[i],
      header=F,as.is=T,sep="\t")$V3[[1]]
    )
}
```

---

Base R histogram

```{r,base_viz_protein_lengths_fix,cache=T,error=T}
hist(lengthz,breaks=50)
```

---

More fancy ggplot

```{r,ggplot_viz_protein_lengths,cache=T,error=T}
library(ggplot2)
ggplot( data.frame(length=lengthz) )+theme_classic()+
  aes(x=length)+geom_histogram(bins=50)

summary(lengthz)
```

---

And that's about how long the viral structural proteins in this database
tend to be.

- How do we extend this analysis to add more files?
- How do we calculate new properties about the sequences?
- How do we store that?


