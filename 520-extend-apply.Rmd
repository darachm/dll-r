
### Extending the workflow

How do you think about/plan the workflow we've built?

One way is to flatten out all the tasks, 
and to script each individual task every time it is done.
This requires the author, user, and reader to understand a lot of complexity.

```{=html}
<div class="incremental">
```

```{=html}
<div class="mermaid">
graph TD
    classDef default line-height:12px;
    classDef three line-height:12px,fill:yellow;
    you[analyst] --> B[finding files] &    C[making a vector] &    D[looping] &    E[reading files] &    F[getting protein seq] &    G[calculting and saving nchar] &    H[plotting nchar]
    B:::three;
    C:::three;
    D:::three;
    E:::three;
    F:::three;
    G:::three;
    H:::three;
</div>
```

Another way to approach this is to cluster them into a hierarchy of modules.

```{=html}
<div class="mermaid">
graph TD
    classDef default line-height:12px;
    classDef one  line-height:12px,fill:pink;
    classDef two line-height:12px,fill:cyan;
    classDef three line-height:12px,fill:yellow;
    you2[analyst] --> find & read & plot;
    find:::one --> B;
    B[finding files]:::three;
    read:::one --> looping & reading;
    looping:::two --> C & D;
    C[making a vector]:::three;
    D[looping]:::three;
    reading[reading and calc]:::two --> E & F & G;
    E[reading files]:::three;
    F[getting protein seq]:::three;
    G[calculting and saving nchar]:::three;
    plot:::one --> H;
    H[plotting nchar]:::three;
</div>
```

In this organization, the analyst can operate at levels of 
<span style="color:magenta">steps</span>,
<span style="color:cyan">modules</span>, and
<span style="color:gold">specific instructions</span>,
depending on what is needed.

```{=html}
</div>
```

---

Organizing your workflows into composable modules lets you extend these to
un-ancipiated complexity. You could imaging using these steps or modules:

```{=html}
<div class="mermaid">
graph LR
    classDef default line-height:12px;
    vp[read viral proteins] --> cl[calculate lengths] --> hist[histogram]
</div>
```

in new ways by composing the elements together, to analyze a different source
of proteins, with a new analysis, with similar plots:

```{=html}
<div class="mermaid">
graph LR
    classDef default line-height:12px;
    vp[read viral proteins] --> cl[calculate lengths] --> hist[histogram]
    hp[read human proteins] --> cl --> boxplot[boxplot]
    vp --> cmotif[find a particular motif] --> motifhist[histogram]
    hp --> cmotif --> motifboxplot[boxplot]
</div>
```

Where maybe these are how the inputs/outputs are defined:

    reading_proteins:
        input: directory path of proteins to read
        output: protein sequences
    calculating lengths:
        input: protein sequences
        output: numeric vector, of lengths
    finding a motif:
        input: protein sequences
        output: numeric vector, of presence/absence

---

#### Looking for a smoking motif...

Some folks believe the insertion of an amino-acid sequence of `PRRA`, relative
to other related coronaviruses, is very rare and a clear sign of engineering.
I don't know hardly anything about furin-cleavage sites or viral evolution,
but we can use the tools we have to look for this sequence in the files.

Let's do that^[
    ...since we're just demonstrating R coding and not representing ourselves as 
    being familiar enough with the field to properly interpret these results.
    I have no idea what occurance of this would mean or not mean, or are we
    doing any sort of statistics or comparisons to null expectations.]:

1. Figure out how to search for "PRRA" in a character string of a protein
    sequence.

    - try using `grepl`, like so: `grepl("PRRA",protein_sequence)`
        where `protein_sequence` is the variable containing the
        protein sequence (similar to what you put into `nchar` before!).

2. Modify your `for` loop to now look for this motif instead of calculating
    number of characters. 
    Save the values in a "numeric" vector.
    ^[Why not logical, since these are logical results? It makes the `hist()`
        step slightly easier.]

3. Plot the results. How often do you find this motif in this dataset?

### Some operations on strings

Character strings are a common type of data, and there's lots of ways to
cut, dice, extract, and recognize elements to help your work.
Here's some ideas:

#### Base R tools

Let's start with one of those above sentences.
You can make a string by putting characters in between single or double quotes:

```{r,examplestring,cache=T}
stringz <- "Character strings are a common type of data, and there's lots of ways to"
stringz
is(stringz)
str(stringz)
```

`grep` and `grepl` are good for searching for patterns (like `grep` in bash).
The first returns position, the second returns `TRUE` or `FALSE`.
What kind of value is that then?

I only ever use `grepl` anymore. It searches for a `pattern` string
in a character vector `x`.

```{r,grepz,cache=T}
grepl(pattern="common type",x=stringz)
grepl("rare type",stringz)
grepl(" [comn]* type",stringz)
```

You can use complex 
[regular expressions](https://bookdown.org/rdpeng/rprogdatascience/regular-expressions.html)
to specify more complex patterns.
These can get 
[really complex](https://r4ds.had.co.nz/strings.html#matching-patterns-with-regular-expressions)
and [really powerful](https://cs.lmu.edu/~ray/notes/regex/).
We're not going to explain these here, except just for the example below.

Ask on Slack later if you'd like more help with something specific.

Also of use is `sub` and `gsub`. 
These substitute patterns with replacements, for the
first occurrence (`sub`) or globally (`gsub`).
These are really handy for modifying data-tables.

For example, let's say you'd like to split up filenames by dates:

```{r,subexample,cache=T}
datar <- data.frame(stringsAsFactors=F,
    filenames=c(
        "210607_pilot_transformation_works.jpeg",
        "210609_transformation_seems_to_work.jpeg",
        "210610_failed_gel_images.jpeg"
    )
)
datar$dates <- gsub(pattern="(\\d\\d\\d\\d\\d\\d)_(.*)\\.jpeg",
        replacement="\\1",x=datar$filenames)
datar$names <- gsub(pattern="(\\d\\d\\d\\d\\d\\d)_(.*)\\.jpeg",
        replacement="\\2",x=datar$filenames)
datar
```

The above uses regular expressions, where `\\d` is matching any digit, 
`.*` matches anything, and `()` denote "groups" to "capture".
In the "replacement", these "groups" are referred to by `\\1` or `\\2`.

There are better (cleaner) ways of doing this...

#### stringr and the tidyverse

The `tidyverse` includes a package `stringr`. This cleans up some of these
basic string operations, makes them more standardized, and gives them nice
standardized names. It's worth using, but you should know about the other
base R functions!

```{r}
library(stringr)
```

For example the above,

```{r,subexample2,cache=T}
datar <- data.frame(stringsAsFactors=F,
    filenames=c(
        "210607_pilot_transformation_works.jpeg",
        "210609_transformation_seems_to_work.jpeg",
        "210610_failed_gel_images.jpeg"
    )
)
datar$dates <- str_extract(string=datar$filenames,pattern="\\d\\d\\d\\d\\d\\d_")
datar
```

There are many options, type `str_` and then TAB.

For much much more about strings, check out 
[Wickham's R4DS book](https://r4ds.had.co.nz/strings.html).
Especially for the special characters part

---

### Back to the motifs

Let's go ahead and look for that sequence, "PRAR" in the structural proteins
we've downloaded here. First, we make one example of that code.

We can start with making a positive and negative control so we can debug
this easily.


```{r,prra_looking_for,cache=T}
test_string_positive <- "APQPRARCGPGP"
test_string_negative <- "AVASTMEMATEY"

grepl(pattern="PRAR",x=test_string_positive)
grepl(pattern="PRAR",x=test_string_negative)
```

Looks good.

---

Now let's modify our previous code to use this line, and store it into
the appropriate position.

How do we do this? 

```{r,loop_for_doing_both_typo,cache=T,error=T}
# listing files
all_files <- list.files(path="data/viral_structural_proteins",
                         full.names=T, pattern=".*tsv")

# initializing vectors
lengthz <- vector("numeric",length(all_files))
motifz  <- vector("logical",length(all_files))

# looping through files
for (i in seq_along(all_files) ) {
  # calculating length and storing it
  lengthz[i] <- nchar( 
        read.delim(all_files[i],
            header=F,as.is=T,sep="\t")$V3[[1]]
    )
  # looking for motif and storing it
  motifz[i]  <- grepl(pattern="PRAR",
        x=read.delim(all_files[i],
            header=F,as.is=T,sep="\t")$V3[[1]]
    )
}
```

Wow! This seems like it's a really rare motif. I wonder what this means,
this may be a smoking gun, this has implic....

---

Oh wait, that's a typo. It's "PRRA" not "PRAR".

```{r,loop_for_doing_both,cache=T,error=T}
# listing files
all_files <- list.files(path="data/viral_structural_proteins",
                         full.names=T, pattern=".*tsv")

# initializing vectors
lengthz <- vector("numeric",length(all_files))
motifz  <- vector("logical",length(all_files))

# looping through files
for (i in seq_along(all_files) ) {
  # calculating length and storing it
  lengthz[i] <- nchar( 
        read.delim(all_files[i],
            header=F,as.is=T,sep="\t")$V3[[1]]
    )
  # looking for motif and storing it
  motifz[i]  <- grepl(pattern="PRRA",
        x=read.delim(all_files[i],
            header=F,as.is=T,sep="\t")$V3[[1]]
    )
}
```

It actually pops up a few times. In what files?

---

Since `motifz` is logical, we can use that to index the files vector:

```{r,which_files,cache=T}
all_files[motifz]
```

Additional questions:

- In what viruses, what proteins does it pop up?
    How does that affect your interpretation?

    How do you use the skills from Day1/2 to look?
    
- Does it show up where you'd expect it to?
    What might that suggest about this dataset?
- How might we come up with a null model for this? 
    How often would this occur? Under what assumptions? 
    How do you test that?
- Your null model might depend on how often certain amino acids tend to
    occur. How might you write some R code to count up each occurance
    of each amino acid?

    Here's a complex line of code that may be adaptable to this problem:

        table(
            factor(
                unlist(
                    strsplit("ACABA",split="")
                ),
                levels=c("A","B","C","D","E","F","G")
            )
        )

    `table` tabulates the occurances of a string/factor,
    `factor` with a `levels` argument can create "spaces" for unobserved
    letters/strings,
    `unlist` turns a list into not a list,
    `strsplit` breaks up a string into a vector of strings using a pattern
    that can also be "".

    I wonder what would happen if these vectors were created for each
    protein, and then summed... 


### Conclusion

- You can use loops to organize repetitive tasks, such as working through a
    large list of files and reading them.
- You can analyze strings using functions like `nchar` or `grepl`.
- Modular design of workflows, using functions or just organized and 
    commented code, can help you extend your analysis to handle new
    questions as they arise

<br/>
<br/>
<br/>
<br/>
<br/>

---

<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>
mermaid.initialize({
    startOnLoad: false, // don't render initially, instead....
    logLevel: 3, // for debugging
});
function initMermaid(s) { 
  var diagrams = document.querySelectorAll('.mermaid');
  var i;
  for(i=0;i<diagrams.length;i++){
    if(diagrams[i].offsetWidth>0){
      mermaid.init(undefined, diagrams[i]);
    }
  }
}
initMermaid();
</script>
