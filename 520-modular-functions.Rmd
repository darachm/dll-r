
<!--

```{=html}
<div class="incremental">
```
```{=html}
</div>
```

-->

## Functions as modular steps

Functions are handy.
For example, let's calculate the standard error of a sample of values:

```{=html}
<div class="incremental">
```
```{r,stderr_fail,error=T}
values <- c(4,3,2,2,5,3,6,2,2,4)
stderr(values)
```
```{=html}
</div>
```

```{=html}
<div class="incremental">
```

Er ... what? What does `stderr` do?

`?stderr`

```{=html}
</div>
```

---

How do you calculate the standard error of the mean of a sample?

```{=html}
<div class="incremental">
```
```{r,stderr_calc,cache=T}
sd(values)/sqrt(length(values))
```

Do we want to type this each time, copy and paste the code each time?

```{r,stderr_calc_2,cache=T}
values2 <- c(10,30,20)
sd(values2)/sqrt(length(values))
```

This can lead to errors in writing, small incorrect parts.
It also leaves all the complexity to the reader, so it makes it harder to
understand when reading code - hard to notice small details.

Where do we save it, how do we share it?

Copy and pasting from a file is okay, but it takes up a lot more work/space.
We could email around a file of code chunks, or share on github.

How do we make sure it works?

This is hard to do with copy-paste code chunks. Changing the chunk to work
on a new input can be an opportunity for introducing errors, typos.

```{=html}
</div>
```

---

#### Write it as a function!

What are the parameters? Are any defaults set?
What does it return?

These can be copy and pasted, or `source()`'d from a `.R` file.
Once you run it, you can test it and change inputs easily.
Later, you could change the function and keep the same script of using the
function.

```{=html}
<div class="incremental">
```
```{r,stderr_test,cache=T}
sez <- function(x) {sd(x)/sqrt(length(x))}
sez(values)

sez(rnorm(10))
sez(rnorm(100))
sez(rpois(1e3,3))
```
```{=html}
</div>
```

---

### Using functions to write modular code

How might you carry out the workflow from the previous work to
calculate protein sequence lengths?

```{=html}
<div class="incremental">
```

One way is to flatten out all the tasks, 
and to script each individual task each time.
This requires the author, user, and reader to understand a lot of complexity.

```{=html}
<div class="mermaid">
graph TD
    classDef default line-height:10px;
    classDef three line-height:10px,fill:yellow;
    you[analyst] --> B[finding files] &    C[making a vector] &    D[looping] &    E[reading files] &    F[getting protein seq] &    G[calculting and saving nchar] &    H[plotting nchar]
    B:::three;
    C:::three;
    D:::three;
    E:::three;
    F:::three;
    G:::three;
    H:::three;
</div>
```

Another way to approach this is to cluster them into a hierarchy of modules.

```{=html}
<div class="mermaid">
graph TD
    classDef default line-height:10px;
    classDef one  line-height:10px,fill:pink;
    classDef two line-height:10px,fill:cyan;
    classDef three line-height:10px,fill:yellow;
    you2[analyst] --> find & read & plot;
    find:::one --> B;
    B[finding files]:::three;
    read:::one --> looping & reading;
    looping:::two --> C & D;
    C[making a vector]:::three;
    D[looping]:::three;
    reading[reading and calc]:::two --> E & F & G;
    E[reading files]:::three;
    F[getting protein seq]:::three;
    G[calculting and saving nchar]:::three;
    plot:::one --> H;
    H[plotting nchar]:::three;
</div>
```

In this organization, the analyst can operate at levels of 
<span style="color:magenta">steps</span>,
<span style="color:cyan">modules</span>, and
<span style="color:gold">specific instructions</span>,
depending on what is needed.

```{=html}
</div>
```

---

Organizing your workflows into composable modules lets you extend these to
un-ancipiated complexity. You could imaging using these steps or modules:

```{=html}
<div class="mermaid">
graph LR
    classDef default line-height:12px;
    vp[read viral proteins] --> cl[calculate lengths] --> hist[histogram]
</div>
```

in new ways by composing the elements together, to analyze a different source
of proteins, with a new analysis, with similar plots:

```{=html}
<div class="mermaid">
graph LR
    classDef default line-height:12px;
    vp[read viral proteins] --> cl[calculate lengths] --> hist[histogram]
    hp[read human proteins] --> cl --> boxplot[boxplot]
    vp --> cgc[calculate GC%] --> gchist[histogram]
    hp --> cgc --> gcboxplot[boxplot]
</div>
```

---

### Tips for modular workflows

- Try to not "hardcode" things - if it's a number, consider if it can be a
    *parameter* that is "passed in" as an argument.

- Group repeated code functions - some folks say you should never repeat
    code (but do what works for you!).

- Try to read inputs and outputs as general, flexible formats -
    strings of filenames, vectors of values

- Write a comment at the top of the function that says what it's doing
    and what to expect, generally comment things.

Consider, the `list.files()` and `hist()` functions are already built this way!
How about a `ggplot2` style boxplot?

---

#### Let's write a plotting module/function

Write a function that makes a ggplot2 boxplot for some numbers.

What should the function take, what should it do?

What is "some numbers"?

What should it return?

[NOTE]: calling ggplot inside a function may not print, you may have to
    wrap it in `print(ggplot code)` or return the ggplot object as
    a variable

---

### More complex workflow

Let's write a simulation of viral evolution.

(could be a bad idea, considering....)

More examples/exercise

show a simulation of somethingâ€¦. genetic drift of a virus replicating?

lineage G1312F

exercise - wrap the entire analysis as a function

talk about ease of calling

ease of tweaking this

exercise - break into subfunctions, generate and plot

ease of changing models

---

### Apply is a popular tool

Apply is another common way of doing something over and over.
It is a very compact way to take pieces of a list, vector, dataframe, or matrix
and put them into a function. There are:

- `apply` - for 2D objects
- `lapply` - for lists and vectors
- `sapply` - is `lapply` but with simplified returns
- `mapply` - is for combinations of multiple variables
- `replicate` - calls a function multiple times

Some people *strongly* prefer coding this way. Here is an example:

```{r,example_apply,cache=T}
list_of_protein_files <- lapply(
        list.files("data/viral_structural_proteins/",full.names=T),
        read.delim,
        sep="\t",header=F)
```

These "apply" some "FUN" to some input variables, by taking each element or
slices of elements from input variables and putting them in as arguments
to the function being applied. They return odd things, often lists (`unlist()`).

---


<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>
mermaid.initialize({
    startOnLoad: false, // don't render initially, instead....
    logLevel: 3, // for debugging
});
function initMermaid(s) { 
  var diagrams = document.querySelectorAll('.mermaid');
  var i;
  for(i=0;i<diagrams.length;i++){
    if(diagrams[i].offsetWidth>0){
      mermaid.init(undefined, diagrams[i]);
    }
  }
}
initMermaid();
</script>
